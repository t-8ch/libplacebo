{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Overview This document will serve as an introduction to and usage example for the libplacebo API. This is not intended as a full API reference, for that you should see the repository of header files , which area written to be (hopefully) understandable as-is. libplacebo exposes large parts of its internal abstractions publicly. This guide will take the general approach of starting as high level as possible and diving into the details in later chapters. A full listing of currently available APIs and their corresponding header files can be seen here . Getting Started To get started using libplacebo, you need to install it (and its development headers) somehow onto your system. On most distributions, this should be as simple as installing the corresponding libplacebo-devel package, or the appropriate variants. You can see a fill list of libplacebo packages and their names on repology . API versions This document is targeting the \"v4 API\" overhaul, and as such, examples provided will generally fail to compile on libplacebo versions below v4.x. Alternatively, you can install it from the source code. For that, see the build instructions located here .","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#overview","text":"This document will serve as an introduction to and usage example for the libplacebo API. This is not intended as a full API reference, for that you should see the repository of header files , which area written to be (hopefully) understandable as-is. libplacebo exposes large parts of its internal abstractions publicly. This guide will take the general approach of starting as high level as possible and diving into the details in later chapters. A full listing of currently available APIs and their corresponding header files can be seen here .","title":"Overview"},{"location":"#getting-started","text":"To get started using libplacebo, you need to install it (and its development headers) somehow onto your system. On most distributions, this should be as simple as installing the corresponding libplacebo-devel package, or the appropriate variants. You can see a fill list of libplacebo packages and their names on repology . API versions This document is targeting the \"v4 API\" overhaul, and as such, examples provided will generally fail to compile on libplacebo versions below v4.x. Alternatively, you can install it from the source code. For that, see the build instructions located here .","title":"Getting Started"},{"location":"basic-rendering/","text":"Basic windowing / output example We will demonstrate the basics of the libplacebo GPU output API with a worked example. The goal is to show a simple color on screen. Creating a pl_log Almost all major entry-points into libplacebo require providing a log callback (or NULL to disable logging). This is abstracted into the pl_log object type, which we can create with pl_log_create : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <libplacebo/log.h> pl_log pllog ; int main () { pllog = pl_log_create ( PL_API_VER , pl_log_params ( . log_cb = pl_log_color , . log_level = PL_LOG_INFO , )); // ... pl_log_destroy ( & pllog ); return 0 ; } Compiling You can compile this example with: $ gcc example.c -o example ` pkg-config --cflags --libs libplacebo ` The parameter PL_API_VER has no special significance and is merely included for historical reasons. Aside from that, this snippet introduces a number of core concepts of the libplacebo API: Parameter structs For extensibility, almost all libplacebo calls take a pointer to a const struct pl_*_params , into which all extensible parameters go. For convenience, libplacebo provides macros which create anonymous params structs on the stack (and also fill in default parameters). Note that this only works for C99 and above, users of C89 and C++ must initialize parameter structs manually. Under the hood, pl_log_params(...) just translates to &((struct pl_log_params) { /* default params */, ... }) . This style of API allows libplacebo to effectively simulate optional named parameters. On default parameters Wherever possible, parameters are designed in such a way that {0} gives you a minimal parameter structure, with default behavior and no optional features enabled. This is done for forwards compatibility - as new features are introduced, old struct initializers will simply opt out of them. Destructors All libplacebo objects must be destroyed manually using the corresponding pl_*_destroy call, which takes a pointer to the variable the object is stored in. The resulting variable is written to NULL . This helps prevent use-after-free bugs. NULL As a general rule, all libplacebo destructors are safe to call on variables containing NULL . So, users need not explicitly NULL -test before calling destructors on variables. Creating a window While libplacebo can work in isolation, to render images offline, for the sake of this guide we want to provide something graphical on-screen. As such, we need to create some sort of window. Libplacebo provides no built-in mechanism for this, it assumes the API user will already have a windowing system in-place. Complete examples (based on GLFW and SDL) can be found in the libplacebo demos . But for now, we will focus on getting a very simple window on-screen using GLFW: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // ... #include <GLFW/glfw3.h> const char * const title = \"libplacebo demo\" ; int width = 800 ; int height = 600 ; GLFWwindow * window ; int main () { pllog = pl_log_create ( PL_API_VER , pl_log_params ( . log_level = PL_LOG_INFO , )); if ( ! glfwInit ()) return 1 ; window = glfwCreateWindow ( width , height , title , NULL , NULL ); if ( ! window ) return 1 ; while ( ! glfwWindowShouldClose ( window )) { glfwWaitEvents (); } glfwDestroyWindow ( window ); glfwTerminate (); pl_log_destroy ( & pllog ); return 0 ; } Compiling We now also need to include the glfw3 library to compile this example. $ gcc example.c -o example ` pkg-config --cflags --libs glfw3 libplacebo ` Creating the pl_gpu All GPU operations are abstracted into an internal pl_gpu object, which serves as the primary entry-point to any sort of GPU interaction. This object cannot be created directly, but must be obtained from some graphical API: currently there are Vulkan, OpenGL or D3D11. A pl_gpu can be accessed from an API-specific object like pl_vulkan , pl_opengl and pl_d3d11 . In this guide, for simplicity, we will be using OpenGL, simply because that's what GLFW initializes by default. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // ... pl_opengl opengl ; static bool make_current ( void * priv ); static void release_current ( void * priv ); int main () { // ... window = glfwCreateWindow ( width , height , title , NULL , NULL ); if ( ! window ) return 1 ; opengl = pl_opengl_create ( pllog , pl_opengl_params ( . get_proc_addr = glfwGetProcAddress , . allow_software = true , // allow software rasterers . debug = true , // enable error reporting . make_current = make_current , // (1) . release_current = release_current , )); if ( ! opengl ) return 2 ; while ( ! glfwWindowShouldClose ( window )) { glfwWaitEvents (); } pl_opengl_destroy ( & opengl ); glfwDestroyWindow ( window ); glfwTerminate (); pl_log_destroy ( & pllog ); return 0 ; } static bool make_current ( void * priv ) { glfwMakeContextCurrent ( window ); return true ; } static void release_current ( void * priv ) { glfwMakeContextCurrent ( NULL ); } Setting this allows the resulting pl_gpu to be thread-safe, which enables asynchronous transfers to be used. The alternative is to simply call glfwMakeContextCurrent once after creating the window. This method of making the context current is generally preferred, however, so we've demonstrated it here for completeness' sake. Creating a swapchain All access to window-based rendering commands are abstracted into an object known as a \"swapchain\" (from Vulkan terminology), including the default backbuffers on D3D11 and OpenGL. If we want to present something to screen, we need to first create a pl_swapchain . We can use this swapchain to perform the equivalent of gl*SwapBuffers : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // ... pl_swapchain swchain ; static void resize_cb ( GLFWwindow * win , int new_w , int new_h ) { width = new_w ; height = new_h ; pl_swapchain_resize ( swchain , & width , & height ); } int main () { // ... if ( ! opengl ) return 2 ; swchain = pl_opengl_create_swapchain ( opengl , pl_opengl_swapchain_params ( . swap_buffers = ( void ( * )( void * )) glfwSwapBuffers , . priv = window , )); if ( ! swchain ) return 2 ; // (2) if ( ! pl_swapchain_resize ( swchain , & width , & height )) return 2 ; glfwSetFramebufferSizeCallback ( window , resize_cb ); while ( ! glfwWindowShouldClose ( window )) { pl_swapchain_swap_buffers ( swchain ); glfwPollEvents (); // (1) } pl_swapchain_destroy ( & swchain ); pl_opengl_destroy ( & opengl ); glfwDestroyWindow ( window ); glfwTerminate (); pl_log_destroy ( & pllog ); return 0 ; } We change this from glfwWaitEvents to glfwPollEvents because we now want to re-run our main loop once per vsync, rather than only when new events arrive. The pl_swapchain_swap_buffers call will ensure that this does not execute too quickly. The swapchain needs to be resized to fit the size of the window, which in GLFW is handled by listening to a callback. In addition to setting this callback, we also need to inform the swapchain of the initial window size. Note that the pl_swapchain_resize function handles both resize requests and size queries - hence, the actual swapchain size is returned back to the passed variables. Getting pixels on the screen With a swapchain in hand, we're now equipped to start drawing pixels to the screen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // ... static void render_frame ( struct pl_swapchain_frame frame ) { pl_gpu gpu = opengl -> gpu ; pl_tex_clear ( gpu , frame . fbo , ( float [ 4 ]){ 1.0 , 0.5 , 0.0 , 1.0 }); } int main () { // ... while ( ! glfwWindowShouldClose ( window )) { struct pl_swapchain_frame frame ; while ( ! pl_swapchain_start_frame ( swchain , & frame )) glfwWaitEvents (); // (1) render_frame ( frame ); if ( ! pl_swapchain_submit_frame ( swchain )) break ; // (2) pl_swapchain_swap_buffers ( swchain ); glfwPollEvents (); } // ... } If pl_swapchain_start_frame fails, it typically means the window is hidden, minimized or blocked. This is not a fatal condition, and as such we simply want to process window events until we can resume rendering. If pl_swapchain_submit_frame fails, it typically means the window has been lost, and further rendering commands are not expected to succeed. As such, in this case, we simply terminate the example program. Our main render loop has changed into a combination of pl_swapchain_start_frame , rendering, and pl_swapchain_submit_frame . To start with, we simply use the pl_tex_clear function to blit a constant orange color to the framebuffer. Interlude: Rendering commands The previous code snippet represented our first foray into the pl_gpu API. For more detail on this API, see the GPU API section. But as a general rule of thumb, all pl_gpu -level operations are thread safe, asynchronous (except when returning something to the CPU), and internally refcounted (so you can destroy all objects as soon as you no longer need the reference). In the example loop, pl_swapchain_swap_buffers is the only operation that actually flushes commands to the GPU. You can force an early flush with pl_gpu_flush() or pl_gpu_finish() , but other than that, commands will \"queue\" internally and complete asynchronously at some unknown point in time, until forward progress is needed (e.g. pl_tex_download ). Conclusion We have demonstrated how to create a window, how to initialize the libplacebo API, create a GPU instance based on OpenGL, and how to write a basic rendering loop that blits a single color to the framebuffer. Here is a complete transcript of the example we built in this section: Basic rendering 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include <GLFW/glfw3.h> #include <libplacebo/log.h> #include <libplacebo/opengl.h> #include <libplacebo/gpu.h> const char * const title = \"libplacebo demo\" ; int width = 800 ; int height = 600 ; GLFWwindow * window ; pl_log pllog ; pl_opengl opengl ; pl_swapchain swchain ; static bool make_current ( void * priv ); static void release_current ( void * priv ); static void resize_cb ( GLFWwindow * win , int new_w , int new_h ) { width = new_w ; height = new_h ; pl_swapchain_resize ( swchain , & width , & height ); } static void render_frame ( struct pl_swapchain_frame frame ) { pl_gpu gpu = opengl -> gpu ; pl_tex_clear ( gpu , frame . fbo , ( float [ 4 ]){ 1.0 , 0.5 , 0.0 , 1.0 }); } int main () { pllog = pl_log_create ( PL_API_VER , pl_log_params ( . log_cb = pl_log_color , . log_level = PL_LOG_INFO , )); if ( ! glfwInit ()) return 1 ; window = glfwCreateWindow ( width , height , title , NULL , NULL ); if ( ! window ) return 1 ; opengl = pl_opengl_create ( pllog , pl_opengl_params ( . get_proc_addr = glfwGetProcAddress , . allow_software = true , // allow software rasterers . debug = true , // enable error reporting . make_current = make_current , . release_current = release_current , )); swchain = pl_opengl_create_swapchain ( opengl , pl_opengl_swapchain_params ( . swap_buffers = ( void ( * )( void * )) glfwSwapBuffers , . priv = window , )); if ( ! swchain ) return 2 ; if ( ! pl_swapchain_resize ( swchain , & width , & height )) return 2 ; glfwSetFramebufferSizeCallback ( window , resize_cb ); while ( ! glfwWindowShouldClose ( window )) { struct pl_swapchain_frame frame ; while ( ! pl_swapchain_start_frame ( swchain , & frame )) glfwWaitEvents (); render_frame ( frame ); if ( ! pl_swapchain_submit_frame ( swchain )) break ; pl_swapchain_swap_buffers ( swchain ); glfwPollEvents (); } pl_swapchain_destroy ( & swchain ); pl_opengl_destroy ( & opengl ); glfwDestroyWindow ( window ); glfwTerminate (); pl_log_destroy ( & pllog ); return 0 ; } static bool make_current ( void * priv ) { glfwMakeContextCurrent ( window ); return true ; } static void release_current ( void * priv ) { glfwMakeContextCurrent ( NULL ); }","title":"Basic windowing / output example"},{"location":"basic-rendering/#basic-windowing-output-example","text":"We will demonstrate the basics of the libplacebo GPU output API with a worked example. The goal is to show a simple color on screen.","title":"Basic windowing / output example"},{"location":"basic-rendering/#creating-a-pl_log","text":"Almost all major entry-points into libplacebo require providing a log callback (or NULL to disable logging). This is abstracted into the pl_log object type, which we can create with pl_log_create : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <libplacebo/log.h> pl_log pllog ; int main () { pllog = pl_log_create ( PL_API_VER , pl_log_params ( . log_cb = pl_log_color , . log_level = PL_LOG_INFO , )); // ... pl_log_destroy ( & pllog ); return 0 ; } Compiling You can compile this example with: $ gcc example.c -o example ` pkg-config --cflags --libs libplacebo ` The parameter PL_API_VER has no special significance and is merely included for historical reasons. Aside from that, this snippet introduces a number of core concepts of the libplacebo API:","title":"Creating a pl_log"},{"location":"basic-rendering/#parameter-structs","text":"For extensibility, almost all libplacebo calls take a pointer to a const struct pl_*_params , into which all extensible parameters go. For convenience, libplacebo provides macros which create anonymous params structs on the stack (and also fill in default parameters). Note that this only works for C99 and above, users of C89 and C++ must initialize parameter structs manually. Under the hood, pl_log_params(...) just translates to &((struct pl_log_params) { /* default params */, ... }) . This style of API allows libplacebo to effectively simulate optional named parameters. On default parameters Wherever possible, parameters are designed in such a way that {0} gives you a minimal parameter structure, with default behavior and no optional features enabled. This is done for forwards compatibility - as new features are introduced, old struct initializers will simply opt out of them.","title":"Parameter structs"},{"location":"basic-rendering/#destructors","text":"All libplacebo objects must be destroyed manually using the corresponding pl_*_destroy call, which takes a pointer to the variable the object is stored in. The resulting variable is written to NULL . This helps prevent use-after-free bugs. NULL As a general rule, all libplacebo destructors are safe to call on variables containing NULL . So, users need not explicitly NULL -test before calling destructors on variables.","title":"Destructors"},{"location":"basic-rendering/#creating-a-window","text":"While libplacebo can work in isolation, to render images offline, for the sake of this guide we want to provide something graphical on-screen. As such, we need to create some sort of window. Libplacebo provides no built-in mechanism for this, it assumes the API user will already have a windowing system in-place. Complete examples (based on GLFW and SDL) can be found in the libplacebo demos . But for now, we will focus on getting a very simple window on-screen using GLFW: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // ... #include <GLFW/glfw3.h> const char * const title = \"libplacebo demo\" ; int width = 800 ; int height = 600 ; GLFWwindow * window ; int main () { pllog = pl_log_create ( PL_API_VER , pl_log_params ( . log_level = PL_LOG_INFO , )); if ( ! glfwInit ()) return 1 ; window = glfwCreateWindow ( width , height , title , NULL , NULL ); if ( ! window ) return 1 ; while ( ! glfwWindowShouldClose ( window )) { glfwWaitEvents (); } glfwDestroyWindow ( window ); glfwTerminate (); pl_log_destroy ( & pllog ); return 0 ; } Compiling We now also need to include the glfw3 library to compile this example. $ gcc example.c -o example ` pkg-config --cflags --libs glfw3 libplacebo `","title":"Creating a window"},{"location":"basic-rendering/#creating-the-pl_gpu","text":"All GPU operations are abstracted into an internal pl_gpu object, which serves as the primary entry-point to any sort of GPU interaction. This object cannot be created directly, but must be obtained from some graphical API: currently there are Vulkan, OpenGL or D3D11. A pl_gpu can be accessed from an API-specific object like pl_vulkan , pl_opengl and pl_d3d11 . In this guide, for simplicity, we will be using OpenGL, simply because that's what GLFW initializes by default. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // ... pl_opengl opengl ; static bool make_current ( void * priv ); static void release_current ( void * priv ); int main () { // ... window = glfwCreateWindow ( width , height , title , NULL , NULL ); if ( ! window ) return 1 ; opengl = pl_opengl_create ( pllog , pl_opengl_params ( . get_proc_addr = glfwGetProcAddress , . allow_software = true , // allow software rasterers . debug = true , // enable error reporting . make_current = make_current , // (1) . release_current = release_current , )); if ( ! opengl ) return 2 ; while ( ! glfwWindowShouldClose ( window )) { glfwWaitEvents (); } pl_opengl_destroy ( & opengl ); glfwDestroyWindow ( window ); glfwTerminate (); pl_log_destroy ( & pllog ); return 0 ; } static bool make_current ( void * priv ) { glfwMakeContextCurrent ( window ); return true ; } static void release_current ( void * priv ) { glfwMakeContextCurrent ( NULL ); } Setting this allows the resulting pl_gpu to be thread-safe, which enables asynchronous transfers to be used. The alternative is to simply call glfwMakeContextCurrent once after creating the window. This method of making the context current is generally preferred, however, so we've demonstrated it here for completeness' sake.","title":"Creating the pl_gpu"},{"location":"basic-rendering/#creating-a-swapchain","text":"All access to window-based rendering commands are abstracted into an object known as a \"swapchain\" (from Vulkan terminology), including the default backbuffers on D3D11 and OpenGL. If we want to present something to screen, we need to first create a pl_swapchain . We can use this swapchain to perform the equivalent of gl*SwapBuffers : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // ... pl_swapchain swchain ; static void resize_cb ( GLFWwindow * win , int new_w , int new_h ) { width = new_w ; height = new_h ; pl_swapchain_resize ( swchain , & width , & height ); } int main () { // ... if ( ! opengl ) return 2 ; swchain = pl_opengl_create_swapchain ( opengl , pl_opengl_swapchain_params ( . swap_buffers = ( void ( * )( void * )) glfwSwapBuffers , . priv = window , )); if ( ! swchain ) return 2 ; // (2) if ( ! pl_swapchain_resize ( swchain , & width , & height )) return 2 ; glfwSetFramebufferSizeCallback ( window , resize_cb ); while ( ! glfwWindowShouldClose ( window )) { pl_swapchain_swap_buffers ( swchain ); glfwPollEvents (); // (1) } pl_swapchain_destroy ( & swchain ); pl_opengl_destroy ( & opengl ); glfwDestroyWindow ( window ); glfwTerminate (); pl_log_destroy ( & pllog ); return 0 ; } We change this from glfwWaitEvents to glfwPollEvents because we now want to re-run our main loop once per vsync, rather than only when new events arrive. The pl_swapchain_swap_buffers call will ensure that this does not execute too quickly. The swapchain needs to be resized to fit the size of the window, which in GLFW is handled by listening to a callback. In addition to setting this callback, we also need to inform the swapchain of the initial window size. Note that the pl_swapchain_resize function handles both resize requests and size queries - hence, the actual swapchain size is returned back to the passed variables.","title":"Creating a swapchain"},{"location":"basic-rendering/#getting-pixels-on-the-screen","text":"With a swapchain in hand, we're now equipped to start drawing pixels to the screen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // ... static void render_frame ( struct pl_swapchain_frame frame ) { pl_gpu gpu = opengl -> gpu ; pl_tex_clear ( gpu , frame . fbo , ( float [ 4 ]){ 1.0 , 0.5 , 0.0 , 1.0 }); } int main () { // ... while ( ! glfwWindowShouldClose ( window )) { struct pl_swapchain_frame frame ; while ( ! pl_swapchain_start_frame ( swchain , & frame )) glfwWaitEvents (); // (1) render_frame ( frame ); if ( ! pl_swapchain_submit_frame ( swchain )) break ; // (2) pl_swapchain_swap_buffers ( swchain ); glfwPollEvents (); } // ... } If pl_swapchain_start_frame fails, it typically means the window is hidden, minimized or blocked. This is not a fatal condition, and as such we simply want to process window events until we can resume rendering. If pl_swapchain_submit_frame fails, it typically means the window has been lost, and further rendering commands are not expected to succeed. As such, in this case, we simply terminate the example program. Our main render loop has changed into a combination of pl_swapchain_start_frame , rendering, and pl_swapchain_submit_frame . To start with, we simply use the pl_tex_clear function to blit a constant orange color to the framebuffer.","title":"Getting pixels on the screen"},{"location":"basic-rendering/#interlude-rendering-commands","text":"The previous code snippet represented our first foray into the pl_gpu API. For more detail on this API, see the GPU API section. But as a general rule of thumb, all pl_gpu -level operations are thread safe, asynchronous (except when returning something to the CPU), and internally refcounted (so you can destroy all objects as soon as you no longer need the reference). In the example loop, pl_swapchain_swap_buffers is the only operation that actually flushes commands to the GPU. You can force an early flush with pl_gpu_flush() or pl_gpu_finish() , but other than that, commands will \"queue\" internally and complete asynchronously at some unknown point in time, until forward progress is needed (e.g. pl_tex_download ).","title":"Interlude: Rendering commands"},{"location":"basic-rendering/#conclusion","text":"We have demonstrated how to create a window, how to initialize the libplacebo API, create a GPU instance based on OpenGL, and how to write a basic rendering loop that blits a single color to the framebuffer. Here is a complete transcript of the example we built in this section: Basic rendering 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include <GLFW/glfw3.h> #include <libplacebo/log.h> #include <libplacebo/opengl.h> #include <libplacebo/gpu.h> const char * const title = \"libplacebo demo\" ; int width = 800 ; int height = 600 ; GLFWwindow * window ; pl_log pllog ; pl_opengl opengl ; pl_swapchain swchain ; static bool make_current ( void * priv ); static void release_current ( void * priv ); static void resize_cb ( GLFWwindow * win , int new_w , int new_h ) { width = new_w ; height = new_h ; pl_swapchain_resize ( swchain , & width , & height ); } static void render_frame ( struct pl_swapchain_frame frame ) { pl_gpu gpu = opengl -> gpu ; pl_tex_clear ( gpu , frame . fbo , ( float [ 4 ]){ 1.0 , 0.5 , 0.0 , 1.0 }); } int main () { pllog = pl_log_create ( PL_API_VER , pl_log_params ( . log_cb = pl_log_color , . log_level = PL_LOG_INFO , )); if ( ! glfwInit ()) return 1 ; window = glfwCreateWindow ( width , height , title , NULL , NULL ); if ( ! window ) return 1 ; opengl = pl_opengl_create ( pllog , pl_opengl_params ( . get_proc_addr = glfwGetProcAddress , . allow_software = true , // allow software rasterers . debug = true , // enable error reporting . make_current = make_current , . release_current = release_current , )); swchain = pl_opengl_create_swapchain ( opengl , pl_opengl_swapchain_params ( . swap_buffers = ( void ( * )( void * )) glfwSwapBuffers , . priv = window , )); if ( ! swchain ) return 2 ; if ( ! pl_swapchain_resize ( swchain , & width , & height )) return 2 ; glfwSetFramebufferSizeCallback ( window , resize_cb ); while ( ! glfwWindowShouldClose ( window )) { struct pl_swapchain_frame frame ; while ( ! pl_swapchain_start_frame ( swchain , & frame )) glfwWaitEvents (); render_frame ( frame ); if ( ! pl_swapchain_submit_frame ( swchain )) break ; pl_swapchain_swap_buffers ( swchain ); glfwPollEvents (); } pl_swapchain_destroy ( & swchain ); pl_opengl_destroy ( & opengl ); glfwDestroyWindow ( window ); glfwTerminate (); pl_log_destroy ( & pllog ); return 0 ; } static bool make_current ( void * priv ) { glfwMakeContextCurrent ( window ); return true ; } static void release_current ( void * priv ) { glfwMakeContextCurrent ( NULL ); }","title":"Conclusion"},{"location":"custom-shaders/","text":"Custom Shaders (mpv .hook syntax) libplacebo supports the same custom shader syntax used by mpv , with some important changes. This document will serve as a complete reference for this syntax. Overview In general, user shaders are divided into distinct blocks . Each block can define a shader, a texture, a buffer, or a tunable parameter. Each block starts with a collection of header directives, which are lines starting with the syntax //! . As an example, here is a simple shader that simply inverts the video signal: 1 2 3 4 5 6 7 8 9 10 //!HOOK LUMA //!HOOK RGB //!BIND HOOKED vec4 hook () { vec4 color = HOOKED_texOff ( 0 ); color . rgb = vec3 ( 1.0 ) - color . rgb ; return color ; } This shader defines one block - a shader block which hooks into the two texture stages LUMA and RGB , binds the hooked texture, inverts the value of the rgb channels, and then returns the modified color. Expressions In a few contexts, shader directives accept arithmetic expressions, denoted by <expr> in the listing below. For historical reasons, all expressions are given in reverse polish notation (RPN) , and the only value type is a floating point number. The following value types and arithmetic operations are available: 1.234 : Literal float constant, evaluates to itself. NAME.w , NAME.width : Evaluates to the width of a texture with name NAME . NAME.h , NAME.height : Evaluates to the height of a texture with name NAME . PAR : Evaluates to the value of a tunable shader parameter with name PAR . + : Evaluates to X+Y . - : Evaluates to X-Y . * : Evaluates to X*Y . / : Evaluates to X/Y . % : Evaluates to fmod(X, Y) . > : Evaluates to (X > Y) ? 1.0 : 0.0 . < : Evaluates to (X < Y) ? 1.0 : 0.0 . = : Evaluates to fuzzy_eq(X, Y) ? 1.0 : 0.0 , with some tolerance to allow for floating point inaccuracy. (Around 1 ppm) ! : Evaluates to X ? 0.0 : 1.0 . Note that + and * can be used as suitable replacements for the otherwise absent boolean logic expressions ( || and && ). Shaders Shaders are the default block type, and have no special syntax to indicate their presence. Shader stages contain raw GLSL code that will be (conditionally) executed. This GLSL snippet must define a single function vec4 hook() , or void hook() for compute shaders. During the execution of any shader, the following global variables are made available: int frame : A raw counter tracking the number of executions of this shader stage. float random : A pseudo-random float uniformly distributed in the range [0,1) . vec2 input_size : The nominal size (in pixels) of the original input image. vec2 target_size : The nominal size (in pixels) of the output rectangle. vec2 tex_offset : The nominal offset (in pixels), of the original input crop. vec4 linearize(vec4 color) : Linearize the input color according to the image's tagged gamma function. vec4 delinearize(vec4 color) : Opposite counterpart to linearize . Shader stages accept the following directives: HOOK <texture> A HOOK directive determines when a shader stage is run. During internal processing, libplacebo goes over a number of pre-defined hook points at set points in the processing pipeline. It is only possible to intercept the image, and run custom shaders, at these fixed hook points. Here is a current list of hook points: RGB : Input plane containing RGB values LUMA : Input plane containing a Y value CHROMA : Input plane containing chroma values (one or both) ALPHA : Input plane containing a single alpha value XYZ : Input plane containing XYZ values CHROMA_SCALED : Chroma plane, after merging and upscaling to luma size ALPHA_SCALED : Alpha plane, after upscaling to luma size NATIVE : Merged input planes, before any sort of color conversion (as-is) MAIN : After conversion to RGB, before linearization/scaling LINEAR : After conversion to linear light (for scaling purposes) SIGMOID : After conversion to sigmoidized light (for scaling purposes) PREKERNEL : Immediately before the execution of the main scaler kernel POSTKERNEL : Immediately after the execution of the main scaler kernel SCALED : After scaling, in either linear or non-linear light RGB OUTPUT : After color conversion to the output display's native colorspace MAINPRESUB In mpv, MAIN and MAINPRESUB are separate shader stages, because the mpv option --blend-subtitles=video allows rendering overlays directly onto the pre-scaled video stage. libplacebo does not support this feature, and as such, the MAINPRESUB shader stage does not exist. It is still valid to refer to this name in shaders, but it is handled identically to MAIN . It's possible for a hook point to never fire. For example, SIGMOID will not fire when downscaling, as sigmoidization only happens when upscaling. Similarly, LUMA / CHROMA will not fire on an RGB video and vice versa. A single shader stage may hook multiple hook points simultaneously, for example, to cover both LUMA and RGB cases with the same logic. (See the example shader in the introduction) BIND <texture> The BIND directive makes a texture available for use in the shader. This can be any of the previously named hook points, a custom texture define by a TEXTURE block, a custom texture saved by a SAVE directive, or the special value HOOKED which allows binding whatever texture hook dispatched this shader stage. A bound texture will define the following GLSL functions (as macros): sampler2D NAME_raw : A reference to the raw texture sampler itself. vec2 NAME_pos : The texel coordinates of the current pixel. vec2 NAME_map(ivec2 id) : A function that maps from gl_GlobalInvocationID to texel coordinates. (Compute shaders) vec2 NAME_size : The size (in pixels) of the texture. vec2 NAME_pt : Convenience macro for 1.0 / NAME_size . The size of a single pixel (in texel coordinates). vec2 NAME_off : The sample offset of the texture. Basically, the pixel coordinates of the top-left corner of the sampled area. float NAME_mul : The coefficient that must be multiplied into sampled values in order to rescale them to [0,1] . vec4 NAME_tex(vec2 pos) : A wrapper around NAME_mul * texture(NAME_raw, pos) , which picks the correct texture function for the version of GLSL in use. vec4 NAME_texOff(vec2 offset) : A wrapper around NAME_tex(NAME_pos + NAME_pt * offset) . This can be used to easily access adjacent pixels, e.g. NAME_texOff(-1,2) samples a pixel one to the left and two to the bottom of the current location. vec4 NAME_gather(vec2 pos, int c) : A wrapper around NAME_mul * textureGather(pos, c) , with appropriate scaling. (Only when supported 1 ) Rotation matrix For compatibility with mpv, we also define a mat2 NAME_rot which is simply equal to a 2x2 identity matrix. libplacebo never rotates input planes - all rotation happens during the final output to the display. This same directive can also be used to bind buffer blocks (i.e. uniform/storage buffers), as defined by the BUFFER directive . SAVE <texture> By default, after execution of a shader stage, the resulting output is captured back into the same hooked texture that triggered the shader. This behavior can be overridden using the explicit SAVE directive. For example, a shader might need access to a low-res version of the luma input texture in order to process chroma: 1 2 3 4 5 6 7 8 9 10 11 //!HOOK CHROMA //!BIND CHROMA //!BIND LUMA //!SAVE LUMA_LOWRES //!WIDTH CHROMA.w //!HEIGHT CHROMA.h vec4 hook () { return LUMA_texOff ( 0 ); } This shader binds both luma and chroma and resizes the luma plane down to the size of the chroma plane, saving the result as a new texture LUMA_LOWRES . In general, you can pick any name you want, here. DESC <description> This purely informative directive simply gives the shader stage a name. This is the name that will be reported to the shader stage and execution time metrics. OFFSET <xo yo | ALIGN> This directive indicates a pixel shift (offset) introduced by this pass. These pixel offsets will be accumulated and corrected automatically as part of plane alignment / main scaling. A special value of ALIGN will attempt to counteract any existing offset of the hooked texture by aligning it with reference plane (i.e. luma). This can be used to e.g. introduce custom chroma scaling in a way that doesn't break chroma subtexel offsets. An example: 1 2 3 4 5 6 7 8 9 //!HOOK LUMA //!BIND HOOKED //!OFFSET 100.5 100.5 vec4 hook () { // Constant offset by N pixels towards the bottom right return HOOKED_texOff ( - vec2 ( 100.5 )); } This (slightly silly) shader simply shifts the entire sampled region to the bottom right by 100.5 pixels, and propagates this shift to the main scaler using the OFFSET directive. As such, the end result of this is that there is no visible shift of the overall image, but some detail (~100 pixels) near the bottom-right border is lost due to falling outside the bounds of the texture. WIDTH <expr> , HEIGHT <expr> These directives can be used to override the dimensions of the resulting texture. Note that not all textures can be resized this way. Currently, only RGB , LUMA , CHROMA , XYZ , NATIVE and MAIN are resizable. Trying to save a texture with an incompatible size to any other shader stage will result in an error. WHEN <expr> This directive takes an expression that can be used to make shader stages conditionally executed. If this evaluates to 0, the shader stage will be skipped. Example: 1 2 3 4 5 6 7 8 9 10 //!PARAM strength //!TYPE float //!MINIMUM 0 1.0 //!HOOK MAIN //!BIND HOOKED //!WHEN intensity 0 > //!DESC do something based on 'intensity' ... This example defines a shader stage that only conditionally executes itself if the value of the intensity shader parameter is non-zero. COMPONENTS <num> This directive overrides the number of components present in a texture. For example, if you want to extract a one-dimensional feature map from the otherwise 3 or 4 dimensional MAIN texture, you can use this directive to save on memory bandwidth and consumption by having libplacebo only allocate a one-component texture to store the feature map in: 1 2 3 4 //!HOOK MAIN //!BIND HOOKED //!SAVE featuremap //!COMPONENTS 1 COMPUTE <bw> <bh> [<tw> <th>] This directive specifies that the shader should be treated as a compute shader, with the block size bw and bh . The compute shader will be dispatched with however many blocks are necessary to completely tile over the output. Within each block, there will be tw*th threads, forming a single work group. In other words: tw and th specify the work group size, which can be different from the block size. So for example, a compute shader with bw = bh = 32 and tw = th = 8 running on a 500x500 texture would dispatch 16x16 blocks (rounded up), each with 8x8 threads. Instead of defining a vec4 hook() , compute shaders must define a void hook() which results directly to the output texture, a writeonly image2D out_image made available to the shader stage. For example, here is a shader executing a single-pass 41x41 convolution (average blur) on the luma plane, using a compute shader to share sampling work between adjacent threads in a work group: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //!HOOK LUMA //!BIND HOOKED //!COMPUTE 32 32 //!DESC avg convolution // Kernel size, 41x41 as an example const ivec2 ksize = ivec2 ( 41 , 41 ); const ivec2 offset = ksize / 2 ; // We need to load extra source texels to account for padding due to kernel // overhang const ivec2 isize = ivec2 ( gl_WorkGroupSize ) + ksize - 1 ; shared float inp [ isize . y ][ isize . x ]; void hook () { // load texels into shmem ivec2 base = ivec2 ( gl_WorkGroupID ) * ivec2 ( gl_WorkGroupSize ); for ( uint y = gl_LocalInvocationID . y ; y < isize . y ; y += gl_WorkGroupSize . y ) { for ( uint x = gl_LocalInvocationID . x ; x < isize . x ; x += gl_WorkGroupSize . x ) inp [ y ][ x ] = texelFetch ( HOOKED_raw , base + ivec2 ( x , y ) - offset , 0 ). x ; } // synchronize threads barrier (); // do convolution float sum ; for ( uint y = 0 ; y < ksize . y ; y ++ ) { for ( uint x = 0 ; x < ksize . x ; x ++ ) sum += inp [ gl_LocalInvocationID . y + y ][ gl_LocalInvocationID . x + x ]; } vec4 color = vec4 ( HOOKED_mul * sum / ( ksize . x * ksize . y ), 0 , 0 , 1 ); imageStore ( out_image , ivec2 ( gl_GlobalInvocationID ), color ); } Textures Custom textures can be defined and made available to shader stages using TEXTURE blocks. These can be used to provide e.g. LUTs or pre-trained weights. The data for a texture is provided as a raw hexadecimal string encoding the in-memory representation of a texture, according to its given texture format, for example: 1 2 3 4 5 6 7 8 9 10 //!TEXTURE COLORS //!SIZE 3 3 //!FORMAT rgba32f //!FILTER NEAREST //!BORDER REPEAT 0000 803 f000000000000000000000000000000000000803f00000000000000000000000 0000000000000 803 f00000000000000000000803f0000803f000000000000803f000000 000000 803 f000000000000803f0000803f00000000000000009a99993e9a99993e9a999 93 e000000009a99193F9A99193f9a99193f000000000000803f0000803f0000803f0000 0000 Texture blocks accept the following directives: TEXTURE <name> This must be the first directive in a texture block, and marks it as such. The name given is the name that the texture will be referred to (via BIND directives). SIZE <width> [<height> [<depth>]] This directive gives the size of the texture, as integers. For example, //!SIZE 512 512 marks a 512x512 texture block. Textures can be 1D, 2D or 3D depending on the number of coordinates specified. FORMAT <fmt> This directive specifies the texture format. A complete list of known textures is exposed as part of the pl_gpu struct metadata, but they follow the format convention rgba8 , rg16hf , rgba32f , r64i and so on. FILTER <LINEAR | NEAREST> This directive specifies the texture magnification/minification filter. BORDER <CLAMP | REPEAT | MIRROR> This directive specifies the border clamping method of the texture. STORAGE If present, this directive marks the texture as a storage image. It will still be initialized with the initial values, but rather than being bound as a read-only and immutable sampler2D , it is bound as a readwrite coherent image2D . Such texture scan be used to, for example, store persistent state across invocations of the shader. Buffers Custom uniform / storage shader buffer blocks can be defined using BUFFER directives. The (initial) data for a buffer is provided as a raw hexadecimal string encoding the in-memory representation of a buffer in the corresponding GLSL packing layout (std140 or std430 for uniform and storage blocks, respectively): 1 2 3 4 5 6 7 8 9 //!BUFFER buf_uniform //!VAR float foo //!VAR float bar 0000000000000000 //!BUFFER buf_storage //!VAR vec2 bat //!VAR int big[32]; //!STORAGE Buffer blocks accept the following directives: BUFFER <name> This must be the first directive in a buffer block, and marks it as such. The name given is mostly cosmetic, as individual variables can be accessed directly using the names given in the corresponding VAR directives. STORAGE If present, this directive marks the buffer as a (readwrite coherent) shader storage block, instead of a readonly uniform buffer block. Such storage blocks can be used to track and evolve state across invocations of this shader. Storage blocks may also be initialized with default data, but this is optional. They can also be initialized as part of the first shader execution (e.g. by testing for frame == 0 ). VAR <type> <name> This directive appends a new variable to the shader block, with GLSL type <type> and shader name <name> . For example, VAR float foo introduces a float foo; member into the buffer block, and VAR mat4 transform introduces a mat4 transform; member. It is also possible to introduce array variables, using [N] as part of the variable name. Tunable parameters Finally, the PARAM directive allows introducing tunable shader parameters, which are exposed programmatically as part of the C API ( pl_hook ). 2 The default value of a parameter is given as the block body, for example: 1 2 3 4 5 6 //!PARAM contrast //!DESC Gain to apply to image brightness //!TYPE float //!MINIMUM 0.0 //!MAXIMUM 100.0 1.0 Parameters accept the following directives: PARAM <name> This must be the first directive in a parameter block, and marks it as such. The name given is the name that will be used to refer to this parameter in GLSL code. DESC <description> This directive can be used to provide a friendlier description of the shader parameter, exposed as part of the C API to end users. MINIMUM <value> , MAXIMUM <value> Provides the minimum/maximum value bound of this parameter. If absent, no minimum/maximum is enforced. TYPE <DEFINE | [DYNAMIC | CONSTANT] <type>> This gives the type of the parameter, which determines what type of values it can hold and how it will be made available to the shader. <type> must be a scalar GLSL numeric type, such as int , float or uint . The optional qualifiers DYNAMIC or CONSTANT mark the parameter as dynamically changing and compile-time constant, respectively. A DYNAMIC variable is assumed to change frequently, and will be grouped with other frequently-changing input parameters. A CONSTANT parameter will be introduced as a compile-time constant into the shader header, which means thy can be used in e.g. constant expressions such as array sizes. 3 Finally, the special type TYPE DEFINE marks a variable as a preprocessor define, which can be used inside #if preprocessor expressions. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //!PARAM taps //!DESC Smoothing taps //!TYPE DEFINE //!MINIMUM 0 //!MAXIMUM 5 2 //!HOOK LUMA //!BIND HOOKED const uint row_size = 2 * taps + 1 ; const float weights [ row_size ] = { #if taps == 0 1.0 , #endif #if taps == 1 0.10650697891920 , 0.78698604216159 , 0.10650697891920 , #endif #if taps == 2 0.05448868454964 , 0.24420134200323 , 0.40261994689424 , 0.24420134200323 , 0.05448868454964 , #endif // ... }; Full example A collection of full examples can be found in the mpv user shaders wiki , but here is an example of a parametrized Gaussian smoothed film grain compute shader: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 //!PARAM intensity //!DESC Film grain intensity //!TYPE float //!MINIMUM 0 0.1 //!PARAM taps //!DESC Film grain smoothing taps //!TYPE DEFINE //!MINIMUM 0 //!MAXIMUM 5 2 //!HOOK LUMA //!BIND HOOKED //!DESC Apply gaussian smoothed film grain //!WHEN intensity 0 > //!COMPUTE 32 32 const uint row_size = 2 * taps + 1 ; const float weights [ row_size ] = { #if taps == 0 1.0 , #endif #if taps == 1 0.10650697891920 , 0.78698604216159 , 0.10650697891920 , #endif #if taps == 2 0.05448868454964 , 0.24420134200323 , 0.40261994689424 , 0.24420134200323 , 0.05448868454964 , #endif #if taps == 3 0.03663284536919 , 0.11128075847888 , 0.21674532140370 , 0.27068214949642 , 0.21674532140370 , 0.11128075847888 , 0.03663284536919 , #endif #if taps == 4 0.02763055063889 , 0.06628224528636 , 0.12383153680577 , 0.18017382291138 , 0.20416368871516 , 0.18017382291138 , 0.12383153680577 , 0.06628224528636 , 0.02763055063889 , #endif #if taps == 5 0.02219054849244 , 0.04558899978527 , 0.07981140824009 , 0.11906462996609 , 0.15136080967773 , 0.16396720767670 , 0.15136080967773 , 0.11906462996609 , 0.07981140824009 , 0.04558899978527 , 0.02219054849244 , #endif }; const uvec2 isize = uvec2 ( gl_WorkGroupSize ) + uvec2 ( 2 * taps ); shared float grain [ isize . y ][ isize . x ]; // PRNG float permute ( float x ) { x = ( 34.0 * x + 1.0 ) * x ; return fract ( x * 1.0 / 289.0 ) * 289.0 ; } float seed ( uvec2 pos ) { const float phi = 1.61803398874989 ; vec3 m = vec3 ( fract ( phi * vec2 ( pos )), random ) + vec3 ( 1.0 ); return permute ( permute ( m . x ) + m . y ) + m . z ; } float rand ( inout float state ) { state = permute ( state ); return fract ( state * 1.0 / 41.0 ); } // Turns uniform white noise into gaussian white noise by passing it // through an approximation of the gaussian quantile function float rand_gaussian ( inout float state ) { const float a0 = 0.151015505647689 ; const float a1 = - 0.5303572634357367 ; const float a2 = 1.365020122861334 ; const float b0 = 0.132089632343748 ; const float b1 = - 0.7607324991323768 ; float p = 0.95 * rand ( state ) + 0.025 ; float q = p - 0.5 ; float r = q * q ; float g = q * ( a2 + ( a1 * r + a0 ) / ( r * r + b1 * r + b0 )); g *= 0.255121822830526 ; // normalize to [-1,1) return g ; } void hook () { // generate grain in `grain` uint num_threads = gl_WorkGroupSize . x * gl_WorkGroupSize . y ; for ( uint i = gl_LocalInvocationIndex ; i < isize . y * isize . x ; i += num_threads ) { uvec2 pos = uvec2 ( i % isize . y , i / isize . y ); float state = seed ( gl_WorkGroupID . xy * gl_WorkGroupSize . xy + pos ); grain [ pos . y ][ pos . x ] = rand_gaussian ( state ); } // make writes visible barrier (); // convolve horizontally for ( uint y = gl_LocalInvocationID . y ; y < isize . y ; y += gl_WorkGroupSize . y ) { float hsum = 0 ; for ( uint x = 0 ; x < row_size ; x ++ ) { float g = grain [ y ][ gl_LocalInvocationID . x + x ]; hsum += weights [ x ] * g ; } // update grain LUT grain [ y ][ gl_LocalInvocationID . x + taps ] = hsum ; } barrier (); // convolve vertically float vsum = 0.0 ; for ( uint y = 0 ; y < row_size ; y ++ ) { float g = grain [ gl_LocalInvocationID . y + y ][ gl_LocalInvocationID . x + taps ]; vsum += weights [ y ] * g ; } vec4 color = HOOKED_tex ( HOOKED_pos ); color . rgb += vec3 ( intensity * vsum ); imageStore ( out_image , ivec2 ( gl_GlobalInvocationID ), color ); } Because these are macros, their presence can be tested for using #ifdef inside the GLSL preprocessor. \u21a9 In mpv using --vo=gpu-next , these can be set using the --glsl-shader-opts option . \u21a9 On supported platforms, these are implemented using specialization constants, which can be updated at run-time without requiring a full shader recompilation. \u21a9","title":"Custom Shaders (mpv .hook syntax)"},{"location":"custom-shaders/#custom-shaders-mpv-hook-syntax","text":"libplacebo supports the same custom shader syntax used by mpv , with some important changes. This document will serve as a complete reference for this syntax.","title":"Custom Shaders (mpv .hook syntax)"},{"location":"custom-shaders/#overview","text":"In general, user shaders are divided into distinct blocks . Each block can define a shader, a texture, a buffer, or a tunable parameter. Each block starts with a collection of header directives, which are lines starting with the syntax //! . As an example, here is a simple shader that simply inverts the video signal: 1 2 3 4 5 6 7 8 9 10 //!HOOK LUMA //!HOOK RGB //!BIND HOOKED vec4 hook () { vec4 color = HOOKED_texOff ( 0 ); color . rgb = vec3 ( 1.0 ) - color . rgb ; return color ; } This shader defines one block - a shader block which hooks into the two texture stages LUMA and RGB , binds the hooked texture, inverts the value of the rgb channels, and then returns the modified color.","title":"Overview"},{"location":"custom-shaders/#expressions","text":"In a few contexts, shader directives accept arithmetic expressions, denoted by <expr> in the listing below. For historical reasons, all expressions are given in reverse polish notation (RPN) , and the only value type is a floating point number. The following value types and arithmetic operations are available: 1.234 : Literal float constant, evaluates to itself. NAME.w , NAME.width : Evaluates to the width of a texture with name NAME . NAME.h , NAME.height : Evaluates to the height of a texture with name NAME . PAR : Evaluates to the value of a tunable shader parameter with name PAR . + : Evaluates to X+Y . - : Evaluates to X-Y . * : Evaluates to X*Y . / : Evaluates to X/Y . % : Evaluates to fmod(X, Y) . > : Evaluates to (X > Y) ? 1.0 : 0.0 . < : Evaluates to (X < Y) ? 1.0 : 0.0 . = : Evaluates to fuzzy_eq(X, Y) ? 1.0 : 0.0 , with some tolerance to allow for floating point inaccuracy. (Around 1 ppm) ! : Evaluates to X ? 0.0 : 1.0 . Note that + and * can be used as suitable replacements for the otherwise absent boolean logic expressions ( || and && ).","title":"Expressions"},{"location":"custom-shaders/#shaders","text":"Shaders are the default block type, and have no special syntax to indicate their presence. Shader stages contain raw GLSL code that will be (conditionally) executed. This GLSL snippet must define a single function vec4 hook() , or void hook() for compute shaders. During the execution of any shader, the following global variables are made available: int frame : A raw counter tracking the number of executions of this shader stage. float random : A pseudo-random float uniformly distributed in the range [0,1) . vec2 input_size : The nominal size (in pixels) of the original input image. vec2 target_size : The nominal size (in pixels) of the output rectangle. vec2 tex_offset : The nominal offset (in pixels), of the original input crop. vec4 linearize(vec4 color) : Linearize the input color according to the image's tagged gamma function. vec4 delinearize(vec4 color) : Opposite counterpart to linearize . Shader stages accept the following directives:","title":"Shaders"},{"location":"custom-shaders/#hook-texture","text":"A HOOK directive determines when a shader stage is run. During internal processing, libplacebo goes over a number of pre-defined hook points at set points in the processing pipeline. It is only possible to intercept the image, and run custom shaders, at these fixed hook points. Here is a current list of hook points: RGB : Input plane containing RGB values LUMA : Input plane containing a Y value CHROMA : Input plane containing chroma values (one or both) ALPHA : Input plane containing a single alpha value XYZ : Input plane containing XYZ values CHROMA_SCALED : Chroma plane, after merging and upscaling to luma size ALPHA_SCALED : Alpha plane, after upscaling to luma size NATIVE : Merged input planes, before any sort of color conversion (as-is) MAIN : After conversion to RGB, before linearization/scaling LINEAR : After conversion to linear light (for scaling purposes) SIGMOID : After conversion to sigmoidized light (for scaling purposes) PREKERNEL : Immediately before the execution of the main scaler kernel POSTKERNEL : Immediately after the execution of the main scaler kernel SCALED : After scaling, in either linear or non-linear light RGB OUTPUT : After color conversion to the output display's native colorspace MAINPRESUB In mpv, MAIN and MAINPRESUB are separate shader stages, because the mpv option --blend-subtitles=video allows rendering overlays directly onto the pre-scaled video stage. libplacebo does not support this feature, and as such, the MAINPRESUB shader stage does not exist. It is still valid to refer to this name in shaders, but it is handled identically to MAIN . It's possible for a hook point to never fire. For example, SIGMOID will not fire when downscaling, as sigmoidization only happens when upscaling. Similarly, LUMA / CHROMA will not fire on an RGB video and vice versa. A single shader stage may hook multiple hook points simultaneously, for example, to cover both LUMA and RGB cases with the same logic. (See the example shader in the introduction)","title":"HOOK &lt;texture&gt;"},{"location":"custom-shaders/#bind-texture","text":"The BIND directive makes a texture available for use in the shader. This can be any of the previously named hook points, a custom texture define by a TEXTURE block, a custom texture saved by a SAVE directive, or the special value HOOKED which allows binding whatever texture hook dispatched this shader stage. A bound texture will define the following GLSL functions (as macros): sampler2D NAME_raw : A reference to the raw texture sampler itself. vec2 NAME_pos : The texel coordinates of the current pixel. vec2 NAME_map(ivec2 id) : A function that maps from gl_GlobalInvocationID to texel coordinates. (Compute shaders) vec2 NAME_size : The size (in pixels) of the texture. vec2 NAME_pt : Convenience macro for 1.0 / NAME_size . The size of a single pixel (in texel coordinates). vec2 NAME_off : The sample offset of the texture. Basically, the pixel coordinates of the top-left corner of the sampled area. float NAME_mul : The coefficient that must be multiplied into sampled values in order to rescale them to [0,1] . vec4 NAME_tex(vec2 pos) : A wrapper around NAME_mul * texture(NAME_raw, pos) , which picks the correct texture function for the version of GLSL in use. vec4 NAME_texOff(vec2 offset) : A wrapper around NAME_tex(NAME_pos + NAME_pt * offset) . This can be used to easily access adjacent pixels, e.g. NAME_texOff(-1,2) samples a pixel one to the left and two to the bottom of the current location. vec4 NAME_gather(vec2 pos, int c) : A wrapper around NAME_mul * textureGather(pos, c) , with appropriate scaling. (Only when supported 1 ) Rotation matrix For compatibility with mpv, we also define a mat2 NAME_rot which is simply equal to a 2x2 identity matrix. libplacebo never rotates input planes - all rotation happens during the final output to the display. This same directive can also be used to bind buffer blocks (i.e. uniform/storage buffers), as defined by the BUFFER directive .","title":"BIND &lt;texture&gt;"},{"location":"custom-shaders/#save-texture","text":"By default, after execution of a shader stage, the resulting output is captured back into the same hooked texture that triggered the shader. This behavior can be overridden using the explicit SAVE directive. For example, a shader might need access to a low-res version of the luma input texture in order to process chroma: 1 2 3 4 5 6 7 8 9 10 11 //!HOOK CHROMA //!BIND CHROMA //!BIND LUMA //!SAVE LUMA_LOWRES //!WIDTH CHROMA.w //!HEIGHT CHROMA.h vec4 hook () { return LUMA_texOff ( 0 ); } This shader binds both luma and chroma and resizes the luma plane down to the size of the chroma plane, saving the result as a new texture LUMA_LOWRES . In general, you can pick any name you want, here.","title":"SAVE &lt;texture&gt;"},{"location":"custom-shaders/#desc-description","text":"This purely informative directive simply gives the shader stage a name. This is the name that will be reported to the shader stage and execution time metrics.","title":"DESC &lt;description&gt;"},{"location":"custom-shaders/#offset-xo-yo-align","text":"This directive indicates a pixel shift (offset) introduced by this pass. These pixel offsets will be accumulated and corrected automatically as part of plane alignment / main scaling. A special value of ALIGN will attempt to counteract any existing offset of the hooked texture by aligning it with reference plane (i.e. luma). This can be used to e.g. introduce custom chroma scaling in a way that doesn't break chroma subtexel offsets. An example: 1 2 3 4 5 6 7 8 9 //!HOOK LUMA //!BIND HOOKED //!OFFSET 100.5 100.5 vec4 hook () { // Constant offset by N pixels towards the bottom right return HOOKED_texOff ( - vec2 ( 100.5 )); } This (slightly silly) shader simply shifts the entire sampled region to the bottom right by 100.5 pixels, and propagates this shift to the main scaler using the OFFSET directive. As such, the end result of this is that there is no visible shift of the overall image, but some detail (~100 pixels) near the bottom-right border is lost due to falling outside the bounds of the texture.","title":"OFFSET &lt;xo yo | ALIGN&gt;"},{"location":"custom-shaders/#width-expr-height-expr","text":"These directives can be used to override the dimensions of the resulting texture. Note that not all textures can be resized this way. Currently, only RGB , LUMA , CHROMA , XYZ , NATIVE and MAIN are resizable. Trying to save a texture with an incompatible size to any other shader stage will result in an error.","title":"WIDTH &lt;expr&gt;, HEIGHT &lt;expr&gt;"},{"location":"custom-shaders/#when-expr","text":"This directive takes an expression that can be used to make shader stages conditionally executed. If this evaluates to 0, the shader stage will be skipped. Example: 1 2 3 4 5 6 7 8 9 10 //!PARAM strength //!TYPE float //!MINIMUM 0 1.0 //!HOOK MAIN //!BIND HOOKED //!WHEN intensity 0 > //!DESC do something based on 'intensity' ... This example defines a shader stage that only conditionally executes itself if the value of the intensity shader parameter is non-zero.","title":"WHEN &lt;expr&gt;"},{"location":"custom-shaders/#components-num","text":"This directive overrides the number of components present in a texture. For example, if you want to extract a one-dimensional feature map from the otherwise 3 or 4 dimensional MAIN texture, you can use this directive to save on memory bandwidth and consumption by having libplacebo only allocate a one-component texture to store the feature map in: 1 2 3 4 //!HOOK MAIN //!BIND HOOKED //!SAVE featuremap //!COMPONENTS 1","title":"COMPONENTS &lt;num&gt;"},{"location":"custom-shaders/#compute-bw-bh-tw-th","text":"This directive specifies that the shader should be treated as a compute shader, with the block size bw and bh . The compute shader will be dispatched with however many blocks are necessary to completely tile over the output. Within each block, there will be tw*th threads, forming a single work group. In other words: tw and th specify the work group size, which can be different from the block size. So for example, a compute shader with bw = bh = 32 and tw = th = 8 running on a 500x500 texture would dispatch 16x16 blocks (rounded up), each with 8x8 threads. Instead of defining a vec4 hook() , compute shaders must define a void hook() which results directly to the output texture, a writeonly image2D out_image made available to the shader stage. For example, here is a shader executing a single-pass 41x41 convolution (average blur) on the luma plane, using a compute shader to share sampling work between adjacent threads in a work group: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //!HOOK LUMA //!BIND HOOKED //!COMPUTE 32 32 //!DESC avg convolution // Kernel size, 41x41 as an example const ivec2 ksize = ivec2 ( 41 , 41 ); const ivec2 offset = ksize / 2 ; // We need to load extra source texels to account for padding due to kernel // overhang const ivec2 isize = ivec2 ( gl_WorkGroupSize ) + ksize - 1 ; shared float inp [ isize . y ][ isize . x ]; void hook () { // load texels into shmem ivec2 base = ivec2 ( gl_WorkGroupID ) * ivec2 ( gl_WorkGroupSize ); for ( uint y = gl_LocalInvocationID . y ; y < isize . y ; y += gl_WorkGroupSize . y ) { for ( uint x = gl_LocalInvocationID . x ; x < isize . x ; x += gl_WorkGroupSize . x ) inp [ y ][ x ] = texelFetch ( HOOKED_raw , base + ivec2 ( x , y ) - offset , 0 ). x ; } // synchronize threads barrier (); // do convolution float sum ; for ( uint y = 0 ; y < ksize . y ; y ++ ) { for ( uint x = 0 ; x < ksize . x ; x ++ ) sum += inp [ gl_LocalInvocationID . y + y ][ gl_LocalInvocationID . x + x ]; } vec4 color = vec4 ( HOOKED_mul * sum / ( ksize . x * ksize . y ), 0 , 0 , 1 ); imageStore ( out_image , ivec2 ( gl_GlobalInvocationID ), color ); }","title":"COMPUTE &lt;bw&gt; &lt;bh&gt; [&lt;tw&gt; &lt;th&gt;]"},{"location":"custom-shaders/#textures","text":"Custom textures can be defined and made available to shader stages using TEXTURE blocks. These can be used to provide e.g. LUTs or pre-trained weights. The data for a texture is provided as a raw hexadecimal string encoding the in-memory representation of a texture, according to its given texture format, for example: 1 2 3 4 5 6 7 8 9 10 //!TEXTURE COLORS //!SIZE 3 3 //!FORMAT rgba32f //!FILTER NEAREST //!BORDER REPEAT 0000 803 f000000000000000000000000000000000000803f00000000000000000000000 0000000000000 803 f00000000000000000000803f0000803f000000000000803f000000 000000 803 f000000000000803f0000803f00000000000000009a99993e9a99993e9a999 93 e000000009a99193F9A99193f9a99193f000000000000803f0000803f0000803f0000 0000 Texture blocks accept the following directives:","title":"Textures"},{"location":"custom-shaders/#texture-name","text":"This must be the first directive in a texture block, and marks it as such. The name given is the name that the texture will be referred to (via BIND directives).","title":"TEXTURE &lt;name&gt;"},{"location":"custom-shaders/#size-width-height-depth","text":"This directive gives the size of the texture, as integers. For example, //!SIZE 512 512 marks a 512x512 texture block. Textures can be 1D, 2D or 3D depending on the number of coordinates specified.","title":"SIZE &lt;width&gt; [&lt;height&gt; [&lt;depth&gt;]]"},{"location":"custom-shaders/#format-fmt","text":"This directive specifies the texture format. A complete list of known textures is exposed as part of the pl_gpu struct metadata, but they follow the format convention rgba8 , rg16hf , rgba32f , r64i and so on.","title":"FORMAT &lt;fmt&gt;"},{"location":"custom-shaders/#filter-linear-nearest","text":"This directive specifies the texture magnification/minification filter.","title":"FILTER &lt;LINEAR | NEAREST&gt;"},{"location":"custom-shaders/#border-clamp-repeat-mirror","text":"This directive specifies the border clamping method of the texture.","title":"BORDER &lt;CLAMP | REPEAT | MIRROR&gt;"},{"location":"custom-shaders/#storage","text":"If present, this directive marks the texture as a storage image. It will still be initialized with the initial values, but rather than being bound as a read-only and immutable sampler2D , it is bound as a readwrite coherent image2D . Such texture scan be used to, for example, store persistent state across invocations of the shader.","title":"STORAGE"},{"location":"custom-shaders/#buffers","text":"Custom uniform / storage shader buffer blocks can be defined using BUFFER directives. The (initial) data for a buffer is provided as a raw hexadecimal string encoding the in-memory representation of a buffer in the corresponding GLSL packing layout (std140 or std430 for uniform and storage blocks, respectively): 1 2 3 4 5 6 7 8 9 //!BUFFER buf_uniform //!VAR float foo //!VAR float bar 0000000000000000 //!BUFFER buf_storage //!VAR vec2 bat //!VAR int big[32]; //!STORAGE Buffer blocks accept the following directives:","title":"Buffers"},{"location":"custom-shaders/#buffer-name","text":"This must be the first directive in a buffer block, and marks it as such. The name given is mostly cosmetic, as individual variables can be accessed directly using the names given in the corresponding VAR directives.","title":"BUFFER &lt;name&gt;"},{"location":"custom-shaders/#storage_1","text":"If present, this directive marks the buffer as a (readwrite coherent) shader storage block, instead of a readonly uniform buffer block. Such storage blocks can be used to track and evolve state across invocations of this shader. Storage blocks may also be initialized with default data, but this is optional. They can also be initialized as part of the first shader execution (e.g. by testing for frame == 0 ).","title":"STORAGE"},{"location":"custom-shaders/#var-type-name","text":"This directive appends a new variable to the shader block, with GLSL type <type> and shader name <name> . For example, VAR float foo introduces a float foo; member into the buffer block, and VAR mat4 transform introduces a mat4 transform; member. It is also possible to introduce array variables, using [N] as part of the variable name.","title":"VAR &lt;type&gt; &lt;name&gt;"},{"location":"custom-shaders/#tunable-parameters","text":"Finally, the PARAM directive allows introducing tunable shader parameters, which are exposed programmatically as part of the C API ( pl_hook ). 2 The default value of a parameter is given as the block body, for example: 1 2 3 4 5 6 //!PARAM contrast //!DESC Gain to apply to image brightness //!TYPE float //!MINIMUM 0.0 //!MAXIMUM 100.0 1.0 Parameters accept the following directives:","title":"Tunable parameters"},{"location":"custom-shaders/#param-name","text":"This must be the first directive in a parameter block, and marks it as such. The name given is the name that will be used to refer to this parameter in GLSL code.","title":"PARAM &lt;name&gt;"},{"location":"custom-shaders/#desc-description_1","text":"This directive can be used to provide a friendlier description of the shader parameter, exposed as part of the C API to end users.","title":"DESC &lt;description&gt;"},{"location":"custom-shaders/#minimum-value-maximum-value","text":"Provides the minimum/maximum value bound of this parameter. If absent, no minimum/maximum is enforced.","title":"MINIMUM &lt;value&gt;, MAXIMUM &lt;value&gt;"},{"location":"custom-shaders/#type-define-dynamic-constant-type","text":"This gives the type of the parameter, which determines what type of values it can hold and how it will be made available to the shader. <type> must be a scalar GLSL numeric type, such as int , float or uint . The optional qualifiers DYNAMIC or CONSTANT mark the parameter as dynamically changing and compile-time constant, respectively. A DYNAMIC variable is assumed to change frequently, and will be grouped with other frequently-changing input parameters. A CONSTANT parameter will be introduced as a compile-time constant into the shader header, which means thy can be used in e.g. constant expressions such as array sizes. 3 Finally, the special type TYPE DEFINE marks a variable as a preprocessor define, which can be used inside #if preprocessor expressions. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //!PARAM taps //!DESC Smoothing taps //!TYPE DEFINE //!MINIMUM 0 //!MAXIMUM 5 2 //!HOOK LUMA //!BIND HOOKED const uint row_size = 2 * taps + 1 ; const float weights [ row_size ] = { #if taps == 0 1.0 , #endif #if taps == 1 0.10650697891920 , 0.78698604216159 , 0.10650697891920 , #endif #if taps == 2 0.05448868454964 , 0.24420134200323 , 0.40261994689424 , 0.24420134200323 , 0.05448868454964 , #endif // ... };","title":"TYPE &lt;DEFINE | [DYNAMIC | CONSTANT] &lt;type&gt;&gt;"},{"location":"custom-shaders/#full-example","text":"A collection of full examples can be found in the mpv user shaders wiki , but here is an example of a parametrized Gaussian smoothed film grain compute shader: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 //!PARAM intensity //!DESC Film grain intensity //!TYPE float //!MINIMUM 0 0.1 //!PARAM taps //!DESC Film grain smoothing taps //!TYPE DEFINE //!MINIMUM 0 //!MAXIMUM 5 2 //!HOOK LUMA //!BIND HOOKED //!DESC Apply gaussian smoothed film grain //!WHEN intensity 0 > //!COMPUTE 32 32 const uint row_size = 2 * taps + 1 ; const float weights [ row_size ] = { #if taps == 0 1.0 , #endif #if taps == 1 0.10650697891920 , 0.78698604216159 , 0.10650697891920 , #endif #if taps == 2 0.05448868454964 , 0.24420134200323 , 0.40261994689424 , 0.24420134200323 , 0.05448868454964 , #endif #if taps == 3 0.03663284536919 , 0.11128075847888 , 0.21674532140370 , 0.27068214949642 , 0.21674532140370 , 0.11128075847888 , 0.03663284536919 , #endif #if taps == 4 0.02763055063889 , 0.06628224528636 , 0.12383153680577 , 0.18017382291138 , 0.20416368871516 , 0.18017382291138 , 0.12383153680577 , 0.06628224528636 , 0.02763055063889 , #endif #if taps == 5 0.02219054849244 , 0.04558899978527 , 0.07981140824009 , 0.11906462996609 , 0.15136080967773 , 0.16396720767670 , 0.15136080967773 , 0.11906462996609 , 0.07981140824009 , 0.04558899978527 , 0.02219054849244 , #endif }; const uvec2 isize = uvec2 ( gl_WorkGroupSize ) + uvec2 ( 2 * taps ); shared float grain [ isize . y ][ isize . x ]; // PRNG float permute ( float x ) { x = ( 34.0 * x + 1.0 ) * x ; return fract ( x * 1.0 / 289.0 ) * 289.0 ; } float seed ( uvec2 pos ) { const float phi = 1.61803398874989 ; vec3 m = vec3 ( fract ( phi * vec2 ( pos )), random ) + vec3 ( 1.0 ); return permute ( permute ( m . x ) + m . y ) + m . z ; } float rand ( inout float state ) { state = permute ( state ); return fract ( state * 1.0 / 41.0 ); } // Turns uniform white noise into gaussian white noise by passing it // through an approximation of the gaussian quantile function float rand_gaussian ( inout float state ) { const float a0 = 0.151015505647689 ; const float a1 = - 0.5303572634357367 ; const float a2 = 1.365020122861334 ; const float b0 = 0.132089632343748 ; const float b1 = - 0.7607324991323768 ; float p = 0.95 * rand ( state ) + 0.025 ; float q = p - 0.5 ; float r = q * q ; float g = q * ( a2 + ( a1 * r + a0 ) / ( r * r + b1 * r + b0 )); g *= 0.255121822830526 ; // normalize to [-1,1) return g ; } void hook () { // generate grain in `grain` uint num_threads = gl_WorkGroupSize . x * gl_WorkGroupSize . y ; for ( uint i = gl_LocalInvocationIndex ; i < isize . y * isize . x ; i += num_threads ) { uvec2 pos = uvec2 ( i % isize . y , i / isize . y ); float state = seed ( gl_WorkGroupID . xy * gl_WorkGroupSize . xy + pos ); grain [ pos . y ][ pos . x ] = rand_gaussian ( state ); } // make writes visible barrier (); // convolve horizontally for ( uint y = gl_LocalInvocationID . y ; y < isize . y ; y += gl_WorkGroupSize . y ) { float hsum = 0 ; for ( uint x = 0 ; x < row_size ; x ++ ) { float g = grain [ y ][ gl_LocalInvocationID . x + x ]; hsum += weights [ x ] * g ; } // update grain LUT grain [ y ][ gl_LocalInvocationID . x + taps ] = hsum ; } barrier (); // convolve vertically float vsum = 0.0 ; for ( uint y = 0 ; y < row_size ; y ++ ) { float g = grain [ gl_LocalInvocationID . y + y ][ gl_LocalInvocationID . x + taps ]; vsum += weights [ y ] * g ; } vec4 color = HOOKED_tex ( HOOKED_pos ); color . rgb += vec3 ( intensity * vsum ); imageStore ( out_image , ivec2 ( gl_GlobalInvocationID ), color ); } Because these are macros, their presence can be tested for using #ifdef inside the GLSL preprocessor. \u21a9 In mpv using --vo=gpu-next , these can be set using the --glsl-shader-opts option . \u21a9 On supported platforms, these are implemented using specialization constants, which can be updated at run-time without requiring a full shader recompilation. \u21a9","title":"Full example"},{"location":"renderer/","text":"Rendering content: pl_frame, pl_renderer, and pl_queue This example roughly builds off the previous entry , and as such will not cover the basics of how to create a window, initialize a pl_gpu and get pixels onto the screen. Renderer The pl_renderer set of APIs represents the highest-level interface into libplacebo, and is what most users who simply want to display e.g. a video feed on-screen will want to be using. The basic initialization is straightforward, requiring no extra parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pl_renderer renderer ; init () { renderer = pl_renderer_create ( pllog , gpu ); if ( ! renderer ) goto error ; // ... } uninit () { pl_renderer_destroy ( & renderer ); } What makes the renderer powerful is the large number of pl_render_params it exposes. By default, libplacebo provides several presets to use: pl_render_fast_params : Disables everything except for defaults. This is the fastest possible configuration. pl_render_default_params : Contains the recommended default parameters, including some slightly higher quality scaling, as well as dithering. pl_render_high_quality_params : A preset of reasonable defaults for a higher-end machine (i.e. anything with a discrete GPU). This enables most of the basic functionality, including upscaling, downscaling, debanding and better HDR tone mapping. Covering all of the possible options exposed by pl_render_params is out-of-scope of this example and would be better served by looking at the API documentation . Frames pl_frame is the struct libplacebo uses to group textures and their metadata together into a coherent unit that can be rendered using the renderer. This is not currently a dynamically allocated or refcounted heap object, it is merely a struct that can live on the stack (or anywhere else). The actual data lives in corresponding pl_tex objects referenced in each of the frame's planes. 1 2 3 4 5 6 7 8 9 bool render_frame ( const struct pl_frame * image , const struct pl_swapchain_frame * swframe ) { struct pl_frame target ; pl_frame_from_swapchain ( & target , swframe ); return pl_render_image ( renderer , image , target , & pl_render_default_params ); } Renderer state The pl_renderer is conceptually (almost) stateless. The only thing that is needed to get a different result is to change the render params, which can be varied freely on every call, if the user desires. The one case where this is not entirely true is when using frame mixing (see below), or when using HDR peak detection. In this case, the renderer can be explicitly reset using pl_renderer_flush_cache . To upload frames, the easiest methods are made available as dedicated helpers in <libplacebo/utils/upload.h> , and <libplacebo/utils/libav.h> (for AVFrames). In general, I recommend checking out the demo programs for a clearer illustration of how to use them in practice. Shader cache The renderer internally generates, compiles and caches a potentially large number of shader programs, some of which can be complex. On some platforms (notably D3D11), these can be quite costly to recompile on every program launch. As such, the renderer offers a way to save/restore its internal shader cache from some external location (managed by the API user). The use of this API is highly recommended: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static uint8_t * load_saved_cache (); static void store_saved_cache ( uint8_t * cache , size_t bytes ); void init () { renderer = pl_renderer_create ( pllog , gpu ); if ( ! renderer ) goto error ; uint8_t * cache = load_saved_cache (); if ( cache ) { pl_renderer_load ( renderer , cache ); free ( cache ); } // ... } void uninit () { size_t cache_bytes = pl_renderer_save ( renderer , NULL ); uint8_t * cache = malloc ( cache_bytes ); if ( cache ) { pl_renderer_save ( renderer , cache ); store_saved_cache ( cache , cache_bytes ); free ( cache ); } pl_renderer_destroy ( & renderer ); } Cache safety libplacebo performs only minimal validity checking on the shader cache, and in general, cannot possibly guard against malicious alteration of such files. Loading a cache from an untrusted source represents a remote code execution vector. Frame mixing One of the renderer's most powerful features is its ability to compensate for differences in framerates between the source and display by using frame mixing to blend adjacent frames together. Using this API requires presenting the renderer, at each vsync, with a pl_frame_mix struct, describing the current state of the vsync. In principle, such structs can be constructed by hand. To do this, all of the relevant frames (nearby the vsync timestamp) must be collected, and their relative distances to the vsync determined, by normalizing all PTS values such that the vsync represents time 0.0 (and a distance of 1.0 represents the nominal duration between adjacent frames). Note that timing vsyncs, and determining the correct vsync duration, are both left as problems for the user to solve. 1 . Here could be an example of a valid struct: ( struct pl_frame_mix ) { . num_frames = 6 . frames = ( const struct pl_frame * []) { /* frame 0 */ /* frame 1 */ /* ... */ /* frame 5 */ }, . signatures = ( uint64_t []) { 0x0 , 0x1 , 0x2 , 0x3 , 0x4 , 0x5 // (1) }, . timestamps = ( float []) { -2.4 , -1.4 , -0.4 , 0.6 , 1.6 , 2.6 , // (2) }, . vsync_duration = 0.4 , // 24 fps video on 60 fps display } These must be unique per frame, but always refer to the same frame. For example, this could be based on the frame's PTS, the frame's numerical ID (in order of decoding), or some sort of hash. The details don't matter, only that this uniquely identifies specific frames. Typically, for CFR sources, frame timestamps will always be separated in this list by a distance of 1.0. In this example, the vsync falls roughly halfway (but not quite) in between two adjacent frames (with IDs 0x2 and 0x3). Frame mixing radius In this example, the frame mixing radius (as determined by pl_frame_mix_radius is 3.0 , so we include all frames that fall within the timestamp interval of [-3, 3) . In general, you should consult this function to determine what frames need to be included in the pl_frame_mix - though including more frames than needed is not an error. Frame queue Because this API is rather unwieldy and clumsy to use directly, libplacebo provides a helper abstraction known as pl_queue to assist in transforming some arbitrary source of frames (such as a video decoder) into nicely packed pl_frame_mix structs ready for consumption by the pl_renderer : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <libplacebo/utils/frame_queue.h> pl_queue queue ; void init () { queue = pl_queue_create ( gpu ); } void uninit () { pl_queue_destroy ( & queue ); // ... } This queue can be interacted with through a number of mechanisms: either pushing frames (blocking or non-blocking), or by having the queue poll frames (via blocking or non-blocking callback) as-needed. For a full overview of the various methods of pushing and polling frames, check the API documentation . In this example, I will assume that we have a separate decoder thread pushing frames into the pl_queue in a blocking manner: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static void decoder_thread ( void ) { void * frame ; while (( frame = /* decode new frame */ )) { pl_queue_push_block ( queue , UINT64_MAX , & ( struct pl_source_frame ) { . pts = /* frame pts */ , . duration = /* frame duration */ , . map = /* map callback */ , . unmap = /* unmap callback */ , . frame_data = frame , }); } pl_queue_push ( queue , NULL ); // signal EOF } Now, in our render loop, we want to call pl_queue_update with appropriate values to retrieve the correct frame mix for each vsync: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool render_frame ( const struct pl_swapchain_frame * swframe ) { struct pl_frame_mix mix ; enum pl_queue_status res ; res = pl_queue_update ( queue , & mix , pl_queue_params ( . pts = /* time of next vsync */ , . radius = pl_frame_mix_radius ( & render_params ), . vsync_duration = /* if known */ , . timeout = UINT64_MAX , // (2) )); switch ( res ) { case PL_QUEUE_OK : break ; case PL_QUEUE_EOF : /* no more frames */ return false ; case PL_QUEUE_ERR : goto error ; // (1) } struct pl_frame target ; pl_frame_from_swapchain ( & target , swframe ); return pl_render_image_mix ( renderer , & mix , target , & pl_render_default_params ); } There is a fourth status, PL_QUEUE_MORE , which is returned only if the resulting frame mix is incomplete (and the timeout was reached) - basically this can only happen if the queue runs dry due to frames not being supplied fast enough. In this example, since we are setting timeout to UINT64_MAX , we will never get this return value. Setting this makes pl_queue_update block indefinitely until sufficiently many frames have been pushed into the pl_queue from our separate decoding thread. Deinterlacing The frame queue also vastly simplifies the process of performing motion-adaptive temporal deinterlacing, by automatically linking together adjacent fields/frames. To take advantage of this, all you need to do is set the appropriate field ( pl_source_frame.first_frame ), as well as enabling deinterlacing parameters . However, this may change in the future, as the recent introduction of the Vulkan display timing extension may result in display timing feedback being added to the pl_swapchain API. That said, as of writing, this has not yet happened. \u21a9","title":"Rendering content: pl_frame, pl_renderer, and pl_queue"},{"location":"renderer/#rendering-content-pl_frame-pl_renderer-and-pl_queue","text":"This example roughly builds off the previous entry , and as such will not cover the basics of how to create a window, initialize a pl_gpu and get pixels onto the screen.","title":"Rendering content: pl_frame, pl_renderer, and pl_queue"},{"location":"renderer/#renderer","text":"The pl_renderer set of APIs represents the highest-level interface into libplacebo, and is what most users who simply want to display e.g. a video feed on-screen will want to be using. The basic initialization is straightforward, requiring no extra parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pl_renderer renderer ; init () { renderer = pl_renderer_create ( pllog , gpu ); if ( ! renderer ) goto error ; // ... } uninit () { pl_renderer_destroy ( & renderer ); } What makes the renderer powerful is the large number of pl_render_params it exposes. By default, libplacebo provides several presets to use: pl_render_fast_params : Disables everything except for defaults. This is the fastest possible configuration. pl_render_default_params : Contains the recommended default parameters, including some slightly higher quality scaling, as well as dithering. pl_render_high_quality_params : A preset of reasonable defaults for a higher-end machine (i.e. anything with a discrete GPU). This enables most of the basic functionality, including upscaling, downscaling, debanding and better HDR tone mapping. Covering all of the possible options exposed by pl_render_params is out-of-scope of this example and would be better served by looking at the API documentation .","title":"Renderer"},{"location":"renderer/#frames","text":"pl_frame is the struct libplacebo uses to group textures and their metadata together into a coherent unit that can be rendered using the renderer. This is not currently a dynamically allocated or refcounted heap object, it is merely a struct that can live on the stack (or anywhere else). The actual data lives in corresponding pl_tex objects referenced in each of the frame's planes. 1 2 3 4 5 6 7 8 9 bool render_frame ( const struct pl_frame * image , const struct pl_swapchain_frame * swframe ) { struct pl_frame target ; pl_frame_from_swapchain ( & target , swframe ); return pl_render_image ( renderer , image , target , & pl_render_default_params ); } Renderer state The pl_renderer is conceptually (almost) stateless. The only thing that is needed to get a different result is to change the render params, which can be varied freely on every call, if the user desires. The one case where this is not entirely true is when using frame mixing (see below), or when using HDR peak detection. In this case, the renderer can be explicitly reset using pl_renderer_flush_cache . To upload frames, the easiest methods are made available as dedicated helpers in <libplacebo/utils/upload.h> , and <libplacebo/utils/libav.h> (for AVFrames). In general, I recommend checking out the demo programs for a clearer illustration of how to use them in practice.","title":"Frames"},{"location":"renderer/#shader-cache","text":"The renderer internally generates, compiles and caches a potentially large number of shader programs, some of which can be complex. On some platforms (notably D3D11), these can be quite costly to recompile on every program launch. As such, the renderer offers a way to save/restore its internal shader cache from some external location (managed by the API user). The use of this API is highly recommended: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static uint8_t * load_saved_cache (); static void store_saved_cache ( uint8_t * cache , size_t bytes ); void init () { renderer = pl_renderer_create ( pllog , gpu ); if ( ! renderer ) goto error ; uint8_t * cache = load_saved_cache (); if ( cache ) { pl_renderer_load ( renderer , cache ); free ( cache ); } // ... } void uninit () { size_t cache_bytes = pl_renderer_save ( renderer , NULL ); uint8_t * cache = malloc ( cache_bytes ); if ( cache ) { pl_renderer_save ( renderer , cache ); store_saved_cache ( cache , cache_bytes ); free ( cache ); } pl_renderer_destroy ( & renderer ); } Cache safety libplacebo performs only minimal validity checking on the shader cache, and in general, cannot possibly guard against malicious alteration of such files. Loading a cache from an untrusted source represents a remote code execution vector.","title":"Shader cache"},{"location":"renderer/#frame-mixing","text":"One of the renderer's most powerful features is its ability to compensate for differences in framerates between the source and display by using frame mixing to blend adjacent frames together. Using this API requires presenting the renderer, at each vsync, with a pl_frame_mix struct, describing the current state of the vsync. In principle, such structs can be constructed by hand. To do this, all of the relevant frames (nearby the vsync timestamp) must be collected, and their relative distances to the vsync determined, by normalizing all PTS values such that the vsync represents time 0.0 (and a distance of 1.0 represents the nominal duration between adjacent frames). Note that timing vsyncs, and determining the correct vsync duration, are both left as problems for the user to solve. 1 . Here could be an example of a valid struct: ( struct pl_frame_mix ) { . num_frames = 6 . frames = ( const struct pl_frame * []) { /* frame 0 */ /* frame 1 */ /* ... */ /* frame 5 */ }, . signatures = ( uint64_t []) { 0x0 , 0x1 , 0x2 , 0x3 , 0x4 , 0x5 // (1) }, . timestamps = ( float []) { -2.4 , -1.4 , -0.4 , 0.6 , 1.6 , 2.6 , // (2) }, . vsync_duration = 0.4 , // 24 fps video on 60 fps display } These must be unique per frame, but always refer to the same frame. For example, this could be based on the frame's PTS, the frame's numerical ID (in order of decoding), or some sort of hash. The details don't matter, only that this uniquely identifies specific frames. Typically, for CFR sources, frame timestamps will always be separated in this list by a distance of 1.0. In this example, the vsync falls roughly halfway (but not quite) in between two adjacent frames (with IDs 0x2 and 0x3). Frame mixing radius In this example, the frame mixing radius (as determined by pl_frame_mix_radius is 3.0 , so we include all frames that fall within the timestamp interval of [-3, 3) . In general, you should consult this function to determine what frames need to be included in the pl_frame_mix - though including more frames than needed is not an error.","title":"Frame mixing"},{"location":"renderer/#frame-queue","text":"Because this API is rather unwieldy and clumsy to use directly, libplacebo provides a helper abstraction known as pl_queue to assist in transforming some arbitrary source of frames (such as a video decoder) into nicely packed pl_frame_mix structs ready for consumption by the pl_renderer : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <libplacebo/utils/frame_queue.h> pl_queue queue ; void init () { queue = pl_queue_create ( gpu ); } void uninit () { pl_queue_destroy ( & queue ); // ... } This queue can be interacted with through a number of mechanisms: either pushing frames (blocking or non-blocking), or by having the queue poll frames (via blocking or non-blocking callback) as-needed. For a full overview of the various methods of pushing and polling frames, check the API documentation . In this example, I will assume that we have a separate decoder thread pushing frames into the pl_queue in a blocking manner: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static void decoder_thread ( void ) { void * frame ; while (( frame = /* decode new frame */ )) { pl_queue_push_block ( queue , UINT64_MAX , & ( struct pl_source_frame ) { . pts = /* frame pts */ , . duration = /* frame duration */ , . map = /* map callback */ , . unmap = /* unmap callback */ , . frame_data = frame , }); } pl_queue_push ( queue , NULL ); // signal EOF } Now, in our render loop, we want to call pl_queue_update with appropriate values to retrieve the correct frame mix for each vsync: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 bool render_frame ( const struct pl_swapchain_frame * swframe ) { struct pl_frame_mix mix ; enum pl_queue_status res ; res = pl_queue_update ( queue , & mix , pl_queue_params ( . pts = /* time of next vsync */ , . radius = pl_frame_mix_radius ( & render_params ), . vsync_duration = /* if known */ , . timeout = UINT64_MAX , // (2) )); switch ( res ) { case PL_QUEUE_OK : break ; case PL_QUEUE_EOF : /* no more frames */ return false ; case PL_QUEUE_ERR : goto error ; // (1) } struct pl_frame target ; pl_frame_from_swapchain ( & target , swframe ); return pl_render_image_mix ( renderer , & mix , target , & pl_render_default_params ); } There is a fourth status, PL_QUEUE_MORE , which is returned only if the resulting frame mix is incomplete (and the timeout was reached) - basically this can only happen if the queue runs dry due to frames not being supplied fast enough. In this example, since we are setting timeout to UINT64_MAX , we will never get this return value. Setting this makes pl_queue_update block indefinitely until sufficiently many frames have been pushed into the pl_queue from our separate decoding thread.","title":"Frame queue"},{"location":"renderer/#deinterlacing","text":"The frame queue also vastly simplifies the process of performing motion-adaptive temporal deinterlacing, by automatically linking together adjacent fields/frames. To take advantage of this, all you need to do is set the appropriate field ( pl_source_frame.first_frame ), as well as enabling deinterlacing parameters . However, this may change in the future, as the recent introduction of the Vulkan display timing extension may result in display timing feedback being added to the pl_swapchain API. That said, as of writing, this has not yet happened. \u21a9","title":"Deinterlacing"}]}